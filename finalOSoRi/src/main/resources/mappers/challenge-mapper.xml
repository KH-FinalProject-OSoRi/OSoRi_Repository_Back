<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="challengeMapper">

  <select id="getChallengeList"
          resultType="com.kh.osori.challenges.model.vo.Challenge">
    SELECT *
    FROM CHALLENGES
    WHERE STATUS = 'Y'
      AND CHALLENGE_MODE = #{challengeMode}
  </select>
  
  <!-- 추가 -->
  <insert id="joinMyChallenge"
          parameterType="com.kh.osori.challenges.model.vo.MyChall">
    INSERT INTO MYCHALL (
      CHALLENGE_ID,
      USER_ID,
      STATUS,
      START_DATE,
      END_DATE
    )
    VALUES (
      #{challengeId},
      #{userId},
      #{status},  #{startDate},
      #{endDate}
    )
  </insert>

  <select id="getMyChallengeList"
          parameterType="map"
          resultType="com.kh.osori.challenges.model.vo.MyChall">
    SELECT
      CHALLENGE_ID AS challengeId,
      USER_ID      AS userId,
      STATUS       AS status,
      START_DATE   AS startDate,
      END_DATE     AS endDate
    FROM MYCHALL
    WHERE USER_ID = #{userId}
    <if test="challengeMode != null and challengeMode != ''">
      AND CHALLENGE_ID IN (
        SELECT CHALLENGE_ID
        FROM CHALLENGES
        WHERE CHALLENGE_MODE = #{challengeMode}
      )
    </if>
    AND (
	  STATUS = 'PROCEEDING'
	  OR STATUS = 'RESERVED'
	  OR STATUS = 'SUCCESS'
	 )
    ORDER BY START_DATE DESC
  </select>

  <select id="getMyPastChallengeList"
          parameterType="map"
          resultType="com.kh.osori.challenges.model.vo.MyChallHistory">
    SELECT
      mc.CHALLENGE_ID  AS challengeId,
      ch.DESCRIPTION   AS description,
      ch.TARGET        AS target,
      ch.TARGET_COUNT  AS targetCount,
      ch.DURATION      AS duration,
      ch.CATEGORY      AS category,
      ch.TYPE          AS type,
      mc.STATUS        AS status,
      mc.START_DATE    AS startDate,
      mc.END_DATE      AS endDate
    FROM MYCHALL mc
    JOIN CHALLENGES ch
      ON mc.CHALLENGE_ID = ch.CHALLENGE_ID
    WHERE mc.USER_ID = #{userId}
    <if test="challengeMode != null and challengeMode != ''">
      AND ch.CHALLENGE_MODE = #{challengeMode}
    </if>
    AND (
     mc.END_DATE &lt; TRUNC(SYSDATE)
     OR mc.STATUS IN ('SUCCESS', 'FAILED')
    ) 
    ORDER BY mc.END_DATE DESC
  </select>

  <!-- 챌린지 단건 조회 -->
  <select id="selectChallengeById"
          parameterType="string"
          resultType="com.kh.osori.challenges.model.vo.Challenge">
    SELECT
      CHALLENGE_ID   AS challengeId,
      DESCRIPTION    AS description,
      TARGET         AS target,
      DURATION       AS duration,
      CATEGORY       AS category,
      TYPE           AS type,
      STATUS         AS status,
      TARGET_COUNT   AS targetCount,
      CHALLENGE_MODE AS challengeMode
    FROM CHALLENGES
    WHERE CHALLENGE_ID = #{challengeId}
  </select>

  <!-- 기간 내 수입 요약 (MYTRANS) -->
  <select id="getIncomeSummaryByRange"
          parameterType="map"
          resultType="hashmap">
    SELECT
      NVL(SUM(ORIGINAL_AMOUNT), 0) AS "sum",
      COUNT(*) AS "cnt"
    FROM MYTRANS
    WHERE USER_ID = #{userId}
      AND TYPE = 'IN'
      AND TRUNC(TRANS_DATE) &gt;= TO_DATE(#{fromDate}, 'YYYY-MM-DD')
      AND TRUNC(TRANS_DATE) &lt;= TO_DATE(#{toDate}, 'YYYY-MM-DD')
  </select>

  <!-- 기간 내 지출 요약 (MYTRANS) -->
  <select id="getExpenseSummaryByRange"
          parameterType="map"
          resultType="hashmap">
    SELECT
      NVL(SUM(ORIGINAL_AMOUNT), 0) AS "sum",
      COUNT(*) AS "cnt"
    FROM MYTRANS
    WHERE USER_ID = #{userId}
      AND TYPE = 'OUT'
      AND TRUNC(TRANS_DATE) &gt;= TO_DATE(#{fromDate}, 'YYYY-MM-DD')
      AND TRUNC(TRANS_DATE) &lt;= TO_DATE(#{toDate}, 'YYYY-MM-DD')
  </select>

  <!-- ========================= -->
  <!-- 스케줄러: MYCHALL 상태 자동 갱신 -->
  <!-- ========================= -->

  <!-- 1) RESERVED -> PROCEEDING (START_DATE 도래) -->
  <update id="promoteReservedToProceeding">
    UPDATE MYCHALL
    SET STATUS = 'PROCEEDING'
    WHERE STATUS = 'RESERVED'
      AND TRUNC(START_DATE) &lt;= TRUNC(SYSDATE)
  </update>

  <!-- 2) 종료된 진행중 챌린지 목록 -->
  <select id="selectEndedProceedingChallenges"
          resultType="com.kh.osori.challenges.model.vo.MyChallHistory">
    SELECT
      mc.CHALLENGE_ID     AS challengeId,
      mc.USER_ID          AS userId,
      mc.STATUS           AS status,
      mc.START_DATE       AS startDate,
      mc.END_DATE         AS endDate,
      ch.DESCRIPTION      AS description,
      ch.TARGET           AS target,
      ch.TARGET_COUNT     AS targetCount,
      ch.DURATION         AS duration,
      ch.CATEGORY         AS category,
      ch.TYPE             AS type,
      ch.CHALLENGE_MODE   AS challengeMode
    FROM MYCHALL mc
    JOIN CHALLENGES ch
      ON mc.CHALLENGE_ID = ch.CHALLENGE_ID
    WHERE mc.STATUS = 'PROCEEDING'
      AND TRUNC(mc.END_DATE) &lt; TRUNC(SYSDATE)
  </select>

  <!-- 스케줄러: 진행 중(종료 안 됨) 챌린지 목록 (즉시 실패 판정 대상) -->
  <select id="selectActiveProceedingChallenges"
          resultType="com.kh.osori.challenges.model.vo.MyChallHistory">
    SELECT
      mc.CHALLENGE_ID     AS challengeId,
      mc.USER_ID          AS userId,
      mc.STATUS           AS status,
      mc.START_DATE       AS startDate,
      mc.END_DATE         AS endDate,
      ch.DESCRIPTION      AS description,
      ch.TARGET           AS target,
      ch.TARGET_COUNT     AS targetCount,
      ch.DURATION         AS duration,
      ch.CATEGORY         AS category,
      ch.TYPE             AS type,
      ch.CHALLENGE_MODE   AS challengeMode
    FROM MYCHALL mc
    JOIN CHALLENGES ch
      ON mc.CHALLENGE_ID = ch.CHALLENGE_ID
    WHERE mc.STATUS = 'PROCEEDING'
      AND TRUNC(mc.END_DATE) &gt;= TRUNC(SYSDATE)
  </select>

  <!-- 3) 상태 업데이트 (기간까지 같이 매칭) -->
  <update id="updateMyChallStatus"
          parameterType="map">
    UPDATE MYCHALL
    SET STATUS = #{status}
    WHERE USER_ID = #{userId}
      AND CHALLENGE_ID = #{challengeId}
      AND TRUNC(START_DATE) = TRUNC(#{startDate})
      AND TRUNC(END_DATE) = TRUNC(#{endDate})
  </update>

  <!-- 기간 내 지출 합계 (카테고리 선택) -->
  <select id="getExpenseSumByRange"
          parameterType="map"
          resultType="hashmap">
    SELECT NVL(SUM(ORIGINAL_AMOUNT), 0) AS sum
    FROM MYTRANS
    WHERE USER_ID = #{userId}
      AND TYPE = 'OUT'
      AND TRUNC(TRANS_DATE) &gt;= TO_DATE(#{fromDate}, 'YYYY-MM-DD')
      AND TRUNC(TRANS_DATE) &lt;= TO_DATE(#{toDate}, 'YYYY-MM-DD')
    <if test="category != null and category != ''">
      AND CATEGORY = #{category}
    </if>
  </select>

  <!-- 기간 내 지출 건수 (카테고리 선택) -->
  <select id="getExpenseCountByRange"
          parameterType="map"
          resultType="hashmap">
    SELECT COUNT(*) AS cnt
    FROM MYTRANS
    WHERE USER_ID = #{userId}
      AND TYPE = 'OUT'
      AND TRUNC(TRANS_DATE) &gt;= TO_DATE(#{fromDate}, 'YYYY-MM-DD')
      AND TRUNC(TRANS_DATE) &lt;= TO_DATE(#{toDate}, 'YYYY-MM-DD')
    <if test="category != null and category != ''">
      AND CATEGORY = #{category}
    </if>
  </select>

  <!-- 일자별 지출 합계 (하루당 제한형) -->
  <select id="getDailyExpenseSumsByRange"
          parameterType="map"
          resultType="hashmap">
    SELECT
      TO_CHAR(TRUNC(TRANS_DATE), 'YYYY-MM-DD') AS day,
      NVL(SUM(ORIGINAL_AMOUNT), 0)             AS sum
    FROM MYTRANS
    WHERE USER_ID = #{userId}
      AND TYPE = 'OUT'
      AND TRUNC(TRANS_DATE) &gt;= TO_DATE(#{fromDate}, 'YYYY-MM-DD')
      AND TRUNC(TRANS_DATE) &lt;= TO_DATE(#{toDate}, 'YYYY-MM-DD')
    <if test="category != null and category != ''">
      AND CATEGORY = #{category}
    </if>
    GROUP BY TRUNC(TRANS_DATE)
    ORDER BY TRUNC(TRANS_DATE)
  </select>
  
  
  <!-- 그룹챌린지 관련 -->
   <insert id="joinGroupChallenge" parameterType="GroupChall">
		<choose>
	        <when test="challengeId == 'group_reduceZero_competition'">
			  INSERT INTO GROUPCHALL (
			      CHALLENGE_ID,
			      GROUPB_ID,
			      START_DATE,
			      END_DATE,
			      STATUS
			  )
			  SELECT
			      #{challengeId},
			      #{groupbId},
			      SYSDATE,
			      MAX(END_DATE),
			      'PROCEEDING'
			  FROM GROUPBUDGET
			  WHERE GROUPB_ID = #{groupbId}
			</when>
	
	        <otherwise>
	            INSERT INTO GROUPCHALL (
	                CHALLENGE_ID,
	                GROUPB_ID,
	                START_DATE,
	                END_DATE,
	                STATUS
	            ) VALUES (
	                #{challengeId},
	                #{groupbId},
	                #{startDate},
	                #{endDate},       
	                'PROCEEDING'
	            )
	        </otherwise>
	    </choose>
	</insert>
	
	<!-- 그룹 챌린지 참가 시 결과 테이블에도 PROCEEDING 생성 -->
	<insert id="joinGroupChallResult" parameterType="map">
	  MERGE INTO GROUPCHALL_RESULT R
	  USING (
	    SELECT 
	      USER_ID, 
	      GROUPB_ID
	    FROM BUDGETMEM 
	    WHERE GROUPB_ID = #{groupbId}
	  ) M
	  ON (
	    R.GROUPB_ID = M.GROUPB_ID AND 
	    R.CHALLENGE_ID = #{challengeId} AND 
	    R.USER_ID = M.USER_ID
	  )
	  WHEN MATCHED THEN
	    UPDATE SET 
	      STATUS = 'PROCEEDING',
	      START_DATE = #{startDate},
	      END_DATE = #{endDate},
	      UPDATED_AT = SYSDATE,
	      TOTAL_AMOUNT = 0,
	      RNK = NULL
	  WHEN NOT MATCHED THEN
	    INSERT (GROUPB_ID, CHALLENGE_ID, START_DATE, END_DATE, USER_ID, STATUS)
	    VALUES (M.GROUPB_ID, #{challengeId}, #{startDate}, #{endDate}, M.USER_ID, 'PROCEEDING')
	</insert>
	
	<!-- 지출이 등록되는 순간 실패 처리 -->
	<update id="failUserOnZeroChallengeExpense" parameterType="map">
	  UPDATE GROUPCHALL_RESULT
	  SET STATUS = 'FAILED',
	      UPDATED_AT = SYSDATE
	  WHERE GROUPB_ID = #{groupbId}
	    AND CHALLENGE_ID = 'group_zero_challenge'
	    AND STATUS = 'PROCEEDING'
	    AND TRUNC(#{transDate}) BETWEEN TRUNC(START_DATE) AND TRUNC(END_DATE)
	</update>

	
	<!-- 종료 시점에 남은 proceeding들 모두 success로 처리 -->
	<update id="successRemainingZeroChallengeUsers">
	  UPDATE GROUPCHALL_RESULT
	  SET STATUS = 'SUCCESS',  UPDATED_AT = SYSDATE
	  WHERE CHALLENGE_ID = 'group_zero_challenge'
	    AND STATUS = 'PROCEEDING'
	    AND TRUNC(END_DATE) &lt; TRUNC(SYSDATE)
	</update>
	
	<!-- 종료된 competition 찾기(scheduler) -->
	<select id="selectEndedCompetitionChallenges" resultType="map">
	  SELECT DISTINCT
	    G.GROUPB_ID     AS "groupbId",
	    G.CHALLENGE_ID  AS "challengeId",
	    TRUNC(G.START_DATE) AS "startDate",
	    TRUNC(G.END_DATE)   AS "endDate"
	  FROM GROUPCHALL G
	  JOIN GROUPCHALL_RESULT R 
	    ON G.GROUPB_ID = R.GROUPB_ID 
	   AND G.CHALLENGE_ID = R.CHALLENGE_ID
	   AND TRUNC(G.START_DATE) = TRUNC(R.START_DATE)
	  WHERE R.STATUS = 'PROCEEDING'  
	    AND TRUNC(G.END_DATE) &lt; TRUNC(SYSDATE)
	</select>


	
	<!-- 유저별 TOTAL_AMOUNT 계산해서 결과 테이블에 업데이트 -->
	<update id="updateCompetitionTotals" parameterType="map">
	   UPDATE GROUPCHALL_RESULT R
	    SET TOTAL_AMOUNT = (
	        SELECT NVL(SUM(GT.ORIGINAL_AMOUNT), 0)
	        FROM GROUPTRANS GT
	        WHERE GT.GROUPB_ID = R.GROUPB_ID
	          AND GT.USER_ID = R.USER_ID
	          AND GT.TYPE = 'OUT'
	          AND GT.TRANS_DATE &gt;= TRUNC(R.START_DATE)
	          AND GT.TRANS_DATE &lt; TRUNC(R.END_DATE) + 1
	      ),
	      UPDATED_AT = SYSDATE
	    WHERE R.GROUPB_ID = #{groupbId}
	      AND R.CHALLENGE_ID = 'group_reduceZero_competition'
	      AND R.STATUS = 'PROCEEDING'
	</update>
	
	<!-- RankOver() 사용해 공동순위 포함 순위 매기기 -->
	<update id="updateCompetitionRanks" parameterType="map">
	  MERGE INTO GROUPCHALL_RESULT R
	  USING (
	    SELECT
	      R2.GROUPB_ID,
	      R2.CHALLENGE_ID,
	      R2.START_DATE,
	      R2.USER_ID,
	      RANK() OVER (ORDER BY R2.TOTAL_AMOUNT ASC) AS RNK
	    FROM GROUPCHALL_RESULT R2
	    WHERE R2.GROUPB_ID = #{groupbId}
	      AND R2.CHALLENGE_ID = 'group_reduceZero_competition'
	      AND R2.STATUS = 'PROCEEDING'
	  ) S
	  ON (
	    R.GROUPB_ID = S.GROUPB_ID
	    AND R.CHALLENGE_ID = S.CHALLENGE_ID
	    AND R.USER_ID = S.USER_ID
	  )
	  WHEN MATCHED THEN
	    UPDATE SET 
	      R.RNK = S.RNK, 
	      R.UPDATED_AT = SYSDATE
	</update>
	
	<!-- 1등만 성공, 나머진 실패 -->
	<update id="finalizeCompetitionStatus" parameterType="map">
	  UPDATE GROUPCHALL_RESULT
	  SET STATUS = CASE WHEN RNK = 1 THEN 'SUCCESS' ELSE 'FAILED' END,
	      UPDATED_AT = SYSDATE
	  WHERE GROUPB_ID = #{groupbId}
	    AND CHALLENGE_ID = 'group_reduceZero_competition'
	    AND STATUS = 'PROCEEDING'
	</update>
	
	<!-- (C) SUCCESS인 사람만 뱃지 지급 대상 뽑기 (GROUPCHALL_RESULT 기준) -->
	<select id="selectUsersToRewardFromResult" resultType="map">
	  SELECT
	    R.USER_ID  AS "USER_ID",
	    B.BADGE_ID AS "BADGE_ID"
	  FROM GROUPCHALL_RESULT R
	  JOIN BADGE B ON B.CHALLENGE_ID = R.CHALLENGE_ID
	  WHERE R.STATUS = 'SUCCESS'
	    AND R.UPDATED_AT IS NOT NULL
	    AND NOT EXISTS (
	      SELECT 1
	      FROM USERBADGE UB
	      WHERE UB.USER_ID = R.USER_ID
	        AND UB.BADGE_ID = B.BADGE_ID
	    )
	</select>
	
	<!-- (D) USERBADGE 중복방지 INSERT -->
	<insert id="mergeUserBadge" parameterType="map">
	  INSERT INTO USERBADGE (USER_ID, BADGE_ID, EARNED_AT)
	  SELECT #{USER_ID}, #{BADGE_ID}, SYSDATE
	  FROM DUAL
	  WHERE NOT EXISTS (
	    SELECT 1
	    FROM USERBADGE
	    WHERE USER_ID = #{USER_ID}
	      AND BADGE_ID = #{BADGE_ID}
	  )
	</insert>
		
	<update id="closeExpiredGroupChallenges">
	  UPDATE GROUPCHALL
	  SET STATUS = 'CLOSED'
	  WHERE STATUS = 'PROCEEDING'
	    AND TRUNC(END_DATE) &lt; TRUNC(SYSDATE)
	</update>
		
	<select id="getGroupJoinedList" resultType="GroupChall">
	    SELECT 
	        CHALLENGE_ID as challengeId,
	        GROUPB_ID as groupbId,
	        STATUS as status,
	        START_DATE as startDate,
	        END_DATE as endDate
	    FROM GROUPCHALL_RESULT  WHERE GROUPB_ID = #{groupbId}
	      AND USER_ID = #{userId}
	</select>
	
	<!--지출 적게 쓰기 챌린지 순위 매기기 함수-->
	<select id="getGroupRanking" resultType="map">
	  SELECT
	      GT.USER_ID AS "userId",
	      GT.NICKNAME AS "nickname",
	      SUM(GT.ORIGINAL_AMOUNT) AS "totalAmount",
	      RANK() OVER (ORDER BY SUM(GT.ORIGINAL_AMOUNT) ASC) AS "rank"
	  FROM GROUPTRANS GT
	  JOIN GROUPCHALL GC
	    ON GC.GROUPB_ID = GT.GROUPB_ID
	   AND GC.CHALLENGE_ID = #{challengeId}
	   AND GC.STATUS = 'PROCEEDING'
	  WHERE GT.GROUPB_ID = #{groupbId}
	    AND GT.TYPE = 'OUT'
	    AND GT.TRANS_DATE BETWEEN TRUNC(GC.START_DATE)
	                          AND (TRUNC(GC.END_DATE) + 0.99999)
	  GROUP BY GT.USER_ID, GT.NICKNAME
	  ORDER BY "rank" ASC
	</select>

	
	<!--그룹 과거 내역-->
	<select id="getGroupPastChallengeList" resultType="map">
	    SELECT 
	        R.CHALLENGE_ID  AS "challengeId",
	        R.GROUPB_ID     AS "groupbId",
	        R.STATUS        AS "status",
	        R.START_DATE    AS "startDate",
	        R.END_DATE      AS "endDate",
	        R.TOTAL_AMOUNT  AS "totalAmount",
	        R.RNK           AS "rank", 
	        C.DESCRIPTION   AS "description",
	        C.CATEGORY      AS "category",
	        C.TYPE          AS "type"
	    FROM GROUPCHALL_RESULT R
	    JOIN CHALLENGES C ON R.CHALLENGE_ID = C.CHALLENGE_ID
	    WHERE R.USER_ID = #{userId}
	      AND R.GROUPB_ID = #{groupbId}
	    ORDER BY R.END_DATE DESC
	</select>	

	

</mapper>


